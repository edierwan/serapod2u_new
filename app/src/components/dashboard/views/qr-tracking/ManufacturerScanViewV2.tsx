'use client'

import { useState, useEffect, useMemo } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import {
  Scan,
  QrCode,
  Package,
  CheckCircle,
  Trash2,
  Link as LinkIcon,
  RefreshCw,
  ClipboardPaste,
  TrendingUp,
  Box,
  Target,
  Unlink,
  Download,
  AlertTriangle,
  ArrowUpDown,
  ArrowUp,
  ArrowDown,
  XOctagon,
  XCircle,
  Info,
  Zap
} from 'lucide-react'
import { createClient } from '@/lib/supabase/client'
import { useToast } from '@/components/ui/use-toast'
import ModeCReverseCaseView from '@/components/manufacturer/ModeCReverseCaseView'
import { extractOrderNumber } from '@/lib/qr-code-utils'

interface UserProfile {
  id: string
  email: string
  role_code: string
  organization_id: string
  organizations: {
    id: string
    org_name: string
    org_type_code: string
  }
}

interface ManufacturerScanViewProps {
  userProfile: UserProfile
  onViewChange: (view: string) => void
}

interface BatchProgress {
  batch_id: string
  batch_code: string
  batch_status?: string
  order_id: string
  order_no: string
  buyer_org_name: string
  total_master_codes: number
  packed_master_codes: number
  total_unique_codes: number
  packed_unique_codes: number
  planned_unique_codes?: number
  actual_packed_unique_codes?: number
  total_unique_with_buffer?: number
  total_buffer_codes: number
  used_buffer_codes: number
  available_buffer_codes?: number
  master_progress_percentage: number
  unique_progress_percentage: number
  overall_progress_percentage: number
  warehouse_started?: boolean
  warehouse_received_cases?: number
  is_complete: boolean
  latest_scans: any[]
  created_at: string
  packed_case_numbers?: number[]
  partial_case_numbers?: number[]
  empty_case_numbers?: number[]
  case_details?: Array<{
    case_number: number
    expected_units: number
    actual_units: number
    is_packed: boolean
    percentage: number
  }>
}

type ScanOutcome = 'success' | 'already_scanned' | 'duplicate_session' | 'error'

interface ScanResult {
  outcome: ScanOutcome
  message?: string
}

type PackingMode = 'scan_assign' | 'bulk_generate' | 'plan_import' | 'async_reverse'

interface AutoGeneratedCase {
  master_code: string
  case_number: number
  total_units: number
  created_at: string
}

// Helper function to format case numbers as ranges (e.g., "#1-#5, #7, #10-#15")
function formatCaseNumberRanges(numbers: number[]): string {
  if (!numbers || numbers.length === 0) return 'None'
  
  // Sort numbers
  const sorted = [...numbers].sort((a, b) => a - b)
  
  const ranges: string[] = []
  let rangeStart = sorted[0]
  let rangeEnd = sorted[0]
  
  for (let i = 1; i <= sorted.length; i++) {
    const current = sorted[i]
    
    // Check if we're at the end or if there's a gap
    if (i === sorted.length || current !== rangeEnd + 1) {
      // Format the range
      if (rangeStart === rangeEnd) {
        ranges.push(`#${rangeStart}`)
      } else {
        ranges.push(`#${rangeStart}-#${rangeEnd}`)
      }
      
      // Start new range
      if (i < sorted.length) {
        rangeStart = current
        rangeEnd = current
      }
    } else {
      // Continue the range
      rangeEnd = current
    }
  }
  
  return ranges.join(', ')
}

const formatProcessingDuration = (durationMs: number): string => {
  const totalSeconds = Math.max(0, Math.round(durationMs / 1000))
  const minutes = Math.floor(totalSeconds / 60)
  const seconds = totalSeconds % 60
  return `${minutes}m ${seconds.toString().padStart(2, '0')}s`
}

const readResponsePayload = async <T = any>(response: Response): Promise<{ data: T | null; rawText: string }> => {
  try {
    const rawText = await response.text()
    if (!rawText) {
      return { data: null, rawText: '' }
    }

    try {
      return { data: JSON.parse(rawText) as T, rawText }
    } catch {
      return { data: null, rawText }
    }
  } catch (error) {
    console.error('Failed to read response payload', error)
    return { data: null, rawText: '' }
  }
}

export default function ManufacturerScanView({ userProfile }: ManufacturerScanViewProps) {
  // Track component mount status to prevent async operations after unmount
  const [isMounted, setIsMounted] = useState(true)
  
  const [scannedCodes, setScannedCodes] = useState<any[]>([])
  const [masterCode, setMasterCode] = useState('')
  const [qrInput, setQrInput] = useState('')
  const [batchInput, setBatchInput] = useState('')
  const [scanning, setScanning] = useState(false)
  const [linking, setLinking] = useState(false)
  const [markingPerfect, setMarkingPerfect] = useState(false)
  const [unlinking, setUnlinking] = useState<string | null>(null)
  const [selectedOrder, setSelectedOrder] = useState<string>('')
  const [orders, setOrders] = useState<any[]>([])
  const [batchProgress, setBatchProgress] = useState<BatchProgress[]>([])
  const [showBatchInput, setShowBatchInput] = useState(false)
  const [batchScanMode, setBatchScanMode] = useState<'normal' | 'reverse' | 'async_reverse'>('async_reverse')
  const [skipCaseValidation] = useState(true) // Always enabled in V2 - simplified workflow
  const [showMasterBatchInput, setShowMasterBatchInput] = useState(false) // Unused in V2 (kept for planImportCard compatibility)
  const [masterBatchInput, setMasterBatchInput] = useState('') // Unused in V2 (kept for planImportCard compatibility)
  const [batchProcessingActive, setBatchProcessingActive] = useState(false)
  const [batchProcessingProgress, setBatchProcessingProgress] = useState(0)
  const [batchProcessingStatus, setBatchProcessingStatus] = useState('')
  const [batchProcessingMode, setBatchProcessingMode] = useState<'unique-scan' | 'master-link' | null>(null)
  const [batchProcessingSummary, setBatchProcessingSummary] = useState({
    total: 0,
    success: 0,
    duplicates: 0,
    errors: 0
  })
  const [batchOutcomeNotice, setBatchOutcomeNotice] = useState<
    { type: 'duplicate' | 'error' | 'mixed'; message: string } | null
  >(null)
  const [packingMode, setPackingMode] = useState<PackingMode>('scan_assign')
  const [bulkTargetCount, setBulkTargetCount] = useState<number>(0)
  const [bulkGenerating, setBulkGenerating] = useState(false)
  const [recentAutoMasters, setRecentAutoMasters] = useState<AutoGeneratedCase[]>([])
  const [downloadingExcel, setDownloadingExcel] = useState(false)
  const [completingProduction, setCompletingProduction] = useState(false)
  const [markPerfectTiming, setMarkPerfectTiming] = useState<{
    duration: number
    casesProcessed: number
    totalLinked: number
  } | null>(null)
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true) // Smart auto-refresh: ON by default
  const [isPageVisible, setIsPageVisible] = useState(true) // Track if page/tab is visible
  const [lastActivityTime, setLastActivityTime] = useState(Date.now()) // Track last user activity

  const { toast } = useToast()
  const supabase = createClient()
  const currentBatchProgress = batchProgress[0]
  const plannedUniqueCount = currentBatchProgress?.planned_unique_codes ?? currentBatchProgress?.total_unique_codes ?? 0
  const actualPackedUniqueCount = currentBatchProgress?.actual_packed_unique_codes ?? currentBatchProgress?.packed_unique_codes ?? 0
  const displayedPackedUniqueCount = currentBatchProgress ? Math.min(actualPackedUniqueCount, plannedUniqueCount) : 0
  const overflowPackedUniqueCount = Math.max(actualPackedUniqueCount - plannedUniqueCount, 0)
  const bufferTotalCount = currentBatchProgress?.total_buffer_codes ?? 0
  const bufferUsedCount = currentBatchProgress?.used_buffer_codes ?? overflowPackedUniqueCount
  const bufferAvailableCount = currentBatchProgress?.available_buffer_codes ?? Math.max(bufferTotalCount - bufferUsedCount, 0)
  const masterPercent = Math.max(0, Math.min(100, currentBatchProgress?.master_progress_percentage ?? 0))
  const uniquePercent = Math.max(
    0,
    Math.min(
      100,
      currentBatchProgress?.unique_progress_percentage ?? (plannedUniqueCount ? (displayedPackedUniqueCount / plannedUniqueCount) * 100 : 0)
    )
  )
  const overallProgressPercent = Math.max(
    0,
    Math.min(
      100,
      currentBatchProgress?.overall_progress_percentage ?? Math.round((masterPercent + uniquePercent) / 2)
    )
  )
  const isWarehouseIntakeStarted = currentBatchProgress?.warehouse_started ?? false
  const isOrderLocked = isWarehouseIntakeStarted

  useEffect(() => {
    console.info('[ManufacturerScan] Warehouse lock status', {
      orderId: currentBatchProgress?.order_id ?? currentBatchProgress?.batch_id ?? null,
      warehouseStarted: isWarehouseIntakeStarted,
      isOrderLocked
    })
  }, [currentBatchProgress?.order_id, currentBatchProgress?.batch_id, isWarehouseIntakeStarted, isOrderLocked])
  const packingModeOptions: Array<{ id: PackingMode; title: string; description: string; icon: typeof Scan }> = [
    {
      id: 'scan_assign',
      title: 'Mode A ¬∑ Scan & Assign',
      description: 'Scan unique QR codes and immediately link them to an existing master case.',
      icon: Scan
    },
    {
      id: 'bulk_generate',
      title: 'Mode B ¬∑ Bulk Capture ‚Üí Auto Case',
      description: 'Capture unique codes first, then auto-create a new master case when targets are met.',
      icon: Package
    },
    {
      id: 'plan_import',
      title: 'Mode C ¬∑ Import Packing Plan',
      description: 'Paste an Excel export to auto-assign master cases from a planned mapping.',
      icon: ClipboardPaste
    },
    {
      id: 'async_reverse',
      title: 'Mode D ¬∑ Async Reverse (Recommended for 1000+ units)',
      description: 'Background processing - paste exclusions and let server prepare codes while you continue working.',
      icon: ClipboardPaste
    }
  ]
  const expectedUnitsPerCase = useMemo(() => {
    if (!currentBatchProgress) return 0
    if (currentBatchProgress.total_master_codes === 0) return 0
    return Math.round(
      currentBatchProgress.total_unique_codes / Math.max(currentBatchProgress.total_master_codes, 1)
    )
  }, [currentBatchProgress])

  const batchOutcomeVisuals: Record<
    'duplicate' | 'error' | 'mixed',
    {
      icon: typeof AlertTriangle
      title: string
      container: string
      iconClass: string
    }
  > = {
    duplicate: {
      icon: AlertTriangle,
      title: 'Duplicate QR codes skipped',
      container: 'border-amber-300 bg-amber-50 text-amber-900',
      iconClass: 'text-amber-600'
    },
    error: {
      icon: XOctagon,
      title: 'Codes not linked to this order',
      container: 'border-rose-300 bg-rose-50 text-rose-900',
      iconClass: 'text-rose-600'
    },
    mixed: {
      icon: Info,
      title: 'No QR codes were recorded',
      container: 'border-indigo-300 bg-indigo-50 text-indigo-900',
      iconClass: 'text-indigo-600'
    }
  }

  const renderBatchOutcomeNotice = () => {
    if (!batchOutcomeNotice) return null
    const visual = batchOutcomeVisuals[batchOutcomeNotice.type]
    const NoticeIcon = visual.icon
    return (
      <Alert className={`${visual.container} border-2`}>
        <NoticeIcon className={`h-5 w-5 ${visual.iconClass}`} />
        <AlertDescription>
          <p className="font-semibold">{visual.title}</p>
          <p className="mt-1 text-sm leading-relaxed">{batchOutcomeNotice.message}</p>
          <p className="mt-2 text-xs text-gray-500">
            You can continue scanning or paste the next batch whenever you are ready.
          </p>
        </AlertDescription>
      </Alert>
    )
  }

  const parseUniqueBatchInput = (raw: string) =>
    raw
      .split(/\r?\n/)
      .map(line => line.trim())
      .filter(line => line.length > 0)

  const parseMasterBatchInput = (raw: string) => {
    const lines = raw.split(/\r?\n/)
    const mapping = new Map<string, Set<string>>()
    const invalidLines: string[] = []

    for (const rawLine of lines) {
      const line = rawLine.trim()
      if (!line) continue

      const parts = line
        .split(/[\t,]+/)
        .map(token => token.replace(/"/g, '').trim())
        .filter(token => token.length > 0)

      if (parts.length < 2) {
        const preview = parts[0]?.toLowerCase() || ''
        if (!preview.includes('master') && !preview.includes('unique')) {
          invalidLines.push(line)
        }
        continue
      }

      const masterCodeToken = parts[0]
      const childCodes = parts.slice(1).filter(token => token.length > 6)

      if (childCodes.length === 0) {
        invalidLines.push(line)
        continue
      }

      if (!mapping.has(masterCodeToken)) {
        mapping.set(masterCodeToken, new Set())
      }

      const bucket = mapping.get(masterCodeToken)!
      childCodes.forEach(code => bucket.add(code))
    }

    const entries = Array.from(mapping.entries()).map(([master, codes]) => [master, Array.from(codes)] as [string, string[]])
    const totalUnique = entries.reduce((sum, [, codes]) => sum + codes.length, 0)

    return {
      entries,
      invalidLines,
      totalCases: entries.length,
      totalUnique
    }
  }

  const uniqueBatchStats = useMemo(() => {
    const codes = parseUniqueBatchInput(batchInput)
    const uniqueCodes = new Set(codes)
    return {
      lines: batchInput.trim().length === 0 ? 0 : batchInput.split(/\r?\n/).length,
      totalCodes: codes.length,
      uniqueCodes: uniqueCodes.size
    }
  }, [batchInput])

  const masterBatchPreview = useMemo(() => parseMasterBatchInput(masterBatchInput), [masterBatchInput])

  // Global cleanup effect - runs on component unmount
  useEffect(() => {
    console.log('üü¢ [COMPONENT MOUNT] ManufacturerScanView mounted')
    setIsMounted(true)
    
    return () => {
      console.log('üî¥ [COMPONENT UNMOUNT] ManufacturerScanView unmounting - cleaning up all intervals')
      setIsMounted(false)
      // Note: Individual intervals are cleaned up by their respective useEffects
      // This is a final safeguard
    }
  }, [])

  useEffect(() => {
    if (isMounted) {
      loadOrders()
      loadProgress()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isMounted])

  // Auto-set selectedOrder when currentBatchProgress loads with order context
  useEffect(() => {
    if (currentBatchProgress && currentBatchProgress.order_id && !selectedOrder) {
      console.log('üéØ Auto-setting order context from currentBatchProgress:', currentBatchProgress.order_id)
      setSelectedOrder(currentBatchProgress.order_id)
    }
  }, [currentBatchProgress, selectedOrder])

  useEffect(() => {
    if (selectedOrder) {
      loadProgress(selectedOrder)
      // üîÑ IMPORTANT: Clear session state when order changes
      // This prevents stale data from previous order/session causing false duplicates
      console.log('üßπ Clearing scanned codes session for new order:', selectedOrder)
      setScannedCodes([])
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedOrder])

  useEffect(() => {
    if (packingMode !== 'scan_assign') {
      setMasterCode('')
    }

    if (packingMode !== 'bulk_generate') {
      setBulkGenerating(false)
    }
  }, [packingMode])

  // This useEffect is unused in V2 since packingMode is locked to 'scan_assign', but kept for code compatibility
  useEffect(() => {
    if (packingMode === 'plan_import') {
      setShowMasterBatchInput(true)
    } else {
      setShowMasterBatchInput(false)
    }
  }, [packingMode])

  useEffect(() => {
    if (packingMode === 'bulk_generate' && expectedUnitsPerCase && bulkTargetCount === 0) {
      setBulkTargetCount(expectedUnitsPerCase)
    }
  }, [packingMode, expectedUnitsPerCase, bulkTargetCount])

  // Smart Auto-Refresh: Track page visibility and user activity
  useEffect(() => {
    if (typeof window === 'undefined') return

    // Handle page visibility changes (tab switching, minimize)
    const handleVisibilityChange = () => {
      const isVisible = document.visibilityState === 'visible'
      console.log(`üëÅÔ∏è Page visibility changed: ${isVisible ? 'VISIBLE' : 'HIDDEN'}`)
      setIsPageVisible(isVisible)
      
      // Reset activity timer when user comes back
      if (isVisible) {
        setLastActivityTime(Date.now())
      }
    }

    // Track user activity (mouse, keyboard, touch)
    const handleUserActivity = () => {
      setLastActivityTime(Date.now())
    }

    // Listen for visibility changes
    document.addEventListener('visibilitychange', handleVisibilityChange)
    
    // Listen for user activity
    window.addEventListener('mousemove', handleUserActivity)
    window.addEventListener('keydown', handleUserActivity)
    window.addEventListener('touchstart', handleUserActivity)
    window.addEventListener('scroll', handleUserActivity)

    // Cleanup
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
      window.removeEventListener('mousemove', handleUserActivity)
      window.removeEventListener('keydown', handleUserActivity)
      window.removeEventListener('touchstart', handleUserActivity)
      window.removeEventListener('scroll', handleUserActivity)
    }
  }, [])

  // Smart Auto-refresh batch progress with intelligent controls
  useEffect(() => {
    // Only run in browser (not during SSR or after server stop)
    if (typeof window === 'undefined') {
      console.log('‚ö†Ô∏è Skipping auto-refresh - not in browser')
      return
    }

    // Only start polling if:
    // 1. We have an active batch
    // 2. Page is visible (not in background tab)
    // 3. User was active in last 5 minutes
    // 4. Batch is not complete (stop polling when 100% done)
    if (!currentBatchProgress || !selectedOrder) {
      console.log('‚ö†Ô∏è Auto-refresh conditions not met - no batch or order')
      return
    }

    // Stop polling if page is hidden (switched tab)
    if (!isPageVisible) {
      console.log('üí§ Page hidden - pausing auto-refresh')
      return
    }

    // Stop polling after 5 minutes of inactivity
    const INACTIVITY_TIMEOUT = 5 * 60 * 1000 // 5 minutes
    const timeSinceLastActivity = Date.now() - lastActivityTime
    if (timeSinceLastActivity > INACTIVITY_TIMEOUT) {
      console.log('üí§ User inactive for 5 minutes - pausing auto-refresh')
      return
    }

    // Stop polling if batch is 100% complete or status is completed
    const isComplete = currentBatchProgress.is_complete || 
                       currentBatchProgress.batch_status === 'completed' ||
                       (currentBatchProgress.master_progress_percentage >= 100 && 
                        currentBatchProgress.unique_progress_percentage >= 100)
    
    if (isComplete) {
      console.log('‚úÖ Batch is complete - stopping auto-refresh')
      return
    }

    // Only start polling if auto-refresh is enabled
    if (!autoRefreshEnabled) {
      console.log('‚è∏Ô∏è Auto-refresh is paused by user')
      return
    }

    console.log('üîÑ [SMART POLLING START] Starting intelligent batch progress auto-refresh')

    const intervalId = setInterval(() => {
      // Double-check conditions before each refresh
      const currentTimeSinceActivity = Date.now() - lastActivityTime
      if (currentTimeSinceActivity > INACTIVITY_TIMEOUT) {
        console.log('üí§ [POLLING TICK] User inactive - skipping refresh')
        return
      }

      if (document.visibilityState !== 'visible') {
        console.log('üí§ [POLLING TICK] Page hidden - skipping refresh')
        return
      }

      console.log('üîÑ [POLLING TICK] Auto-refreshing batch progress...')
      if (selectedOrder) {
        loadProgress(selectedOrder)
      }
    }, 5000) // Refresh every 5 seconds

    // CRITICAL: Cleanup on unmount or when dependencies change
    return () => {
      console.log('üõë [POLLING CLEANUP] Stopping batch progress auto-refresh, clearing interval:', intervalId)
      clearInterval(intervalId)
    }
  }, [selectedOrder, isPageVisible, autoRefreshEnabled]) // Fixed dependencies - removed lastActivityTime and currentBatchProgress to prevent constant restarts

  const loadOrders = async () => {
    try {
      const { data, error } = await supabase
        .from('orders')
        .select(`
          id,
          order_no,
          status,
          created_at,
          payment_terms,
          organizations!orders_buyer_org_id_fkey (
            org_name
          ),
          qr_batches (
            id
          ),
          order_items (
            line_total
          )
        `)
        .eq('seller_org_id', userProfile.organization_id)
        .in('status', ['approved', 'closed'])
        .order('created_at', { ascending: false })
        .limit(50)

      if (error) throw error
      setOrders(data || [])
    } catch (error: any) {
      console.error('Error loading orders:', error)
    }
  }

  const loadProgress = async (orderId?: string) => {
    // Guard: Don't make API calls if component is unmounted
    if (!isMounted) {
      console.log('‚ö†Ô∏è [loadProgress] Component unmounted - skipping API call')
      return
    }
    
    try {
      // If orderId is explicitly provided (e.g., when user selects different order),
      // always use legacy endpoint to fetch fresh batch data for that order
      // This ensures we don't use stale batch_id from previous order
      if (orderId) {
        const params = new URLSearchParams()
        params.append('order_id', orderId)
        params.append('manufacturer_id', userProfile.organization_id)

        console.log('üì° [loadProgress] Fetching batch progress for order change (legacy endpoint)...', orderId)
        const response = await fetch(`/api/manufacturer/batch-progress?${params.toString()}`)
        if (!response.ok) throw new Error('Failed to load progress')

        const result = await response.json()
        
        // Guard: Only update state if component is still mounted
        if (isMounted) {
          setBatchProgress(result.batches || [])
          console.log('‚úÖ [loadProgress] Batch progress updated for new order (legacy)')
        } else {
          console.log('‚ö†Ô∏è [loadProgress] Component unmounted during fetch - discarding result')
        }
        return
      }

      // Try to use new DB-driven endpoint if we have a batch_id (for refresh polling)
      const currentBatch = batchProgress[0]
      const batchId = currentBatch?.batch_id
      
      if (batchId) {
        // üöÄ NEW: Use optimized DB-driven progress endpoint with indexes
        console.log('üì° [loadProgress] Fetching batch progress (DB-driven with indexes)...')
        const response = await fetch(`/api/qr/batches/${batchId}/progress`)
        if (!response.ok) throw new Error('Failed to load progress')

        const result = await response.json()
        
        // Guard: Only update state if component is still mounted
        if (isMounted) {
          setBatchProgress([result]) // New endpoint returns single batch object
          console.log('‚úÖ [loadProgress] Batch progress updated (DB-driven)')
        } else {
          console.log('‚ö†Ô∏è [loadProgress] Component unmounted during fetch - discarding result')
        }
      } else {
        // Fallback to old endpoint for initial load or when batch_id not available
        const params = new URLSearchParams()
        params.append('manufacturer_id', userProfile.organization_id)

        console.log('üì° [loadProgress] Fetching batch progress (legacy endpoint - initial load)...')
        const response = await fetch(`/api/manufacturer/batch-progress?${params.toString()}`)
        if (!response.ok) throw new Error('Failed to load progress')

        const result = await response.json()
        
        // Guard: Only update state if component is still mounted
        if (isMounted) {
          setBatchProgress(result.batches || [])
          console.log('‚úÖ [loadProgress] Batch progress updated (legacy)')
        } else {
          console.log('‚ö†Ô∏è [loadProgress] Component unmounted during fetch - discarding result')
        }
      }
    } catch (error: any) {
      console.error('‚ùå [loadProgress] Error loading progress:', error)
    }
  }

  const handleScanUnique = async (
    code: string,
    options: { silent?: boolean } = {}
  ): Promise<ScanResult> => {
    const { silent = false } = options

    if (isOrderLocked) {
      if (!silent) {
        toast({
          title: 'Order locked',
          description: 'Warehouse intake has begun for this order. Scanning is disabled to avoid conflicts.',
          variant: 'destructive'
        })
      }
      return { outcome: 'error', message: 'Order locked' }
    }

    if (!code.trim()) {
      if (!silent) {
        toast({
          title: 'Error',
          description: 'Please provide a QR code to scan.',
          variant: 'destructive'
        })
      }
      return { outcome: 'error', message: 'Empty QR code' }
    }

    if (!silent) {
      setScanning(true)
    }

    try {
      const response = await fetch('/api/manufacturer/scan-unique', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ qr_code: code.trim() })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to scan QR code')
      }

      const result = await response.json()

      // ‚úÖ DATABASE CHECK: ONLY authoritative source - no session checking
      // If code has master_code_id or status != 'pending', it's already been processed
      if (result.already_scanned) {
        if (!silent) {
          toast({
            title: 'Warning',
            description: 'This QR code has already been scanned and linked to a master case',
            variant: 'destructive'
          })
        }
        return { outcome: 'already_scanned', message: 'Previously scanned QR code' }
      }

      // ‚úÖ ALWAYS TRUST DATABASE: If DB says code is OK, it's OK
      // Session state is ONLY for UI display, NOT for duplicate detection
      // Check if code already exists in UI list (for display purposes only)
      const existingIndex = scannedCodes.findIndex(c => c.code === result.product_info.code)
      if (existingIndex !== -1) {
        // Code already in UI list - just update it with fresh data
        // This handles the danger zone scenario where DB is reset but UI still has old data
        console.log('üîÑ Code already in UI list, updating with fresh data:', result.product_info.code)
        setScannedCodes(prev => {
          const updated = [...prev]
          updated[existingIndex] = result.product_info // Refresh with new data from DB
          return updated
        })
      } else {
        // New code - add to UI list
        console.log('‚úÖ Adding new code to UI list:', result.product_info.code)
        setScannedCodes(prev => [...prev, result.product_info])
      }

      // ALWAYS return success if database check passed
      if (!silent) {
        setBatchOutcomeNotice(null)
        setQrInput('')
        toast({
          title: 'Success',
          description: `Scanned: ${result.product_info.product_name}`,
        })
      }

      return { outcome: 'success', message: result.product_info.product_name as string }
    } catch (error: any) {
      if (!silent) {
        toast({
          title: 'Error',
          description: error.message,
          variant: 'destructive'
        })
      }
      return { outcome: 'error', message: error.message }
    } finally {
      if (!silent) {
        setScanning(false)
      }
    }
  }

  const handleBatchPasteReverse = async () => {
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Batch paste is disabled.',
        variant: 'destructive'
      })
      return
    }

    setBatchOutcomeNotice(null)
    if (!batchInput.trim()) {
      toast({
        title: 'Error',
        description: 'Please paste QR codes to exclude in the batch input field',
        variant: 'destructive'
      })
      return
    }

    // Get the batch ID from current progress
    if (!currentBatchProgress || !currentBatchProgress.batch_id) {
      toast({
        title: 'Error',
        description: 'No active batch found. Please select an order first.',
        variant: 'destructive'
      })
      return
    }

    const excludeCodes = batchInput
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)

    if (excludeCodes.length === 0) {
      toast({
        title: 'Error',
        description: 'No valid QR codes found to exclude',
        variant: 'destructive'
      })
      return
    }

    // Remove duplicates from exclude list
    const uniqueExcludeCodes = Array.from(new Set(excludeCodes))
    const duplicatesInInput = excludeCodes.length - uniqueExcludeCodes.length

    if (duplicatesInInput > 0) {
      console.log(`‚ö†Ô∏è Found ${duplicatesInInput} duplicate codes in exclude list, will process ${uniqueExcludeCodes.length} unique codes`)
    }

    setBatchProcessingMode('unique-scan')
    setBatchProcessingSummary({
      total: 0,
      success: 0,
      duplicates: 0,
      errors: 0
    })
    setBatchProcessingStatus('Fetching batch codes...')
    setBatchProcessingProgress(10)
    setBatchProcessingActive(true)

    try {
      // Fetch all available codes from the batch, excluding the specified codes
      const response = await fetch('/api/manufacturer/get-batch-codes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          batch_id: currentBatchProgress.batch_id,
          order_id: currentBatchProgress.order_id,
          exclude_codes: uniqueExcludeCodes
        })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to fetch batch codes')
      }

      const result = await response.json()

      console.log('üìä Reverse scan result:', {
        total_available: result.summary.total_available_in_batch,
        excluded: result.summary.excluded_count,
        returned: result.summary.returned_count,
        not_found: result.summary.not_found_exclusions
      })

      setBatchProcessingProgress(30)
      setBatchProcessingStatus(`Processing ${result.codes.length} codes...`)

      if (!result.codes || result.codes.length === 0) {
        throw new Error('No codes available to process after exclusions')
      }

      // Show summary to user
      toast({
        title: 'Reverse Scan Mode',
        description: `Excluded ${result.summary.excluded_count} codes. Processing ${result.codes.length} remaining codes.`,
        variant: 'default'
      })

      // Now scan all the returned codes
      let successCount = 0
      let duplicateCount = 0
      let errorCount = 0

      setBatchProcessingSummary({
        total: result.codes.length,
        success: 0,
        duplicates: 0,
        errors: 0
      })

      for (let index = 0; index < result.codes.length; index++) {
        setBatchProcessingStatus(`Scanning code ${index + 1} of ${result.codes.length}`)

        const scanResult = await handleScanUnique(result.codes[index].code, { silent: true })

        switch (scanResult.outcome) {
          case 'success':
            successCount++
            break
          case 'already_scanned':
          case 'duplicate_session':
            duplicateCount++
            break
          case 'error':
            errorCount++
            break
        }

        const progress = 30 + Math.round(((index + 1) / result.codes.length) * 70)
        setBatchProcessingProgress(progress)
        setBatchProcessingSummary({
          total: result.codes.length,
          success: successCount,
          duplicates: duplicateCount,
          errors: errorCount
        })
        await new Promise(resolve => setTimeout(resolve, 80))
      }

      const updateOutcomeNotice = () => {
        if (successCount === 0) {
          if (duplicateCount > 0 && errorCount === 0) {
            setBatchOutcomeNotice({
              type: 'duplicate',
              message: 'All remaining QR codes were already captured for this order. No new packs were added.'
            })
          } else if (errorCount > 0 && duplicateCount === 0) {
            setBatchOutcomeNotice({
              type: 'error',
              message: 'None of the remaining QR codes could be processed.'
            })
          } else if (duplicateCount + errorCount > 0) {
            setBatchOutcomeNotice({
              type: 'mixed',
              message: 'Duplicates and invalid codes were skipped automatically, so nothing was recorded.'
            })
          }
        }
      }

      setBatchProcessingStatus('Reverse scan complete!')
      setBatchProcessingSummary({
        total: result.codes.length,
        success: successCount,
        duplicates: duplicateCount,
        errors: errorCount
      })
      setBatchProcessingProgress(100)
      updateOutcomeNotice()

      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1200)

      setBatchInput('')
      setShowBatchInput(false)

      toast({
        title: 'Reverse Scan Complete',
        description: `Successfully scanned ${successCount} of ${result.codes.length} codes (excluded ${result.summary.excluded_count} codes).`,
      })
    } catch (error: any) {
      console.error('Error during reverse batch scan:', error)
      setBatchProcessingStatus('Reverse scan failed. Please try again.')
      toast({
        title: 'Error',
        description: error.message || 'Failed to process reverse scan',
        variant: 'destructive'
      })
      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1500)
    }
  }

  const handleBatchPaste = () => {
    // Normal mode logic
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Batch paste is disabled.',
        variant: 'destructive'
      })
      return
    }

    setBatchOutcomeNotice(null)
    if (!batchInput.trim()) {
      toast({
        title: 'Error',
        description: 'Please paste QR codes in the batch input field',
        variant: 'destructive'
      })
      return
    }

    const codes = batchInput
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)

    if (codes.length === 0) {
      toast({
        title: 'Error',
        description: 'No valid QR codes found',
        variant: 'destructive'
      })
      return
    }

    // ‚úÖ CRITICAL FIX: Remove duplicate codes from the input itself
    // If user pastes the same code multiple times, only process once
    const originalCount = codes.length
    const uniqueCodes = Array.from(new Set(codes))
    const duplicatesInInput = originalCount - uniqueCodes.length

    if (duplicatesInInput > 0) {
      console.log(`‚ö†Ô∏è Found ${duplicatesInInput} duplicate codes in batch input, will process ${uniqueCodes.length} unique codes`)
      toast({
        title: 'Duplicates Removed',
        description: `Found ${duplicatesInInput} duplicate codes in your paste. Processing ${uniqueCodes.length} unique codes.`,
        variant: 'default'
      })
    }

    let successCount = 0
    let duplicateCount = 0
    let errorCount = 0

    const startBatch = async () => {
      setBatchProcessingMode('unique-scan')
      setBatchProcessingSummary({
        total: uniqueCodes.length,  // Use uniqueCodes count
        success: 0,
        duplicates: 0,
        errors: 0
      })
      setBatchProcessingStatus('Preparing batch scan...')
      setBatchProcessingProgress(0)
      setBatchProcessingActive(true)

      for (let index = 0; index < uniqueCodes.length; index++) {  // Use uniqueCodes
        setBatchProcessingStatus(`Scanning code ${index + 1} of ${uniqueCodes.length}`)

        const result = await handleScanUnique(uniqueCodes[index], { silent: true })  // Use uniqueCodes

        switch (result.outcome) {
          case 'success':
            successCount++
            break
          case 'already_scanned':
          case 'duplicate_session':
            duplicateCount++
            break
          case 'error':
            errorCount++
            break
        }

        const progress = Math.round(((index + 1) / uniqueCodes.length) * 100)
        setBatchProcessingProgress(progress)
        setBatchProcessingSummary({
          total: uniqueCodes.length,
          success: successCount,
          duplicates: duplicateCount,
          errors: errorCount
        })
        await new Promise(resolve => setTimeout(resolve, 80))
      }

      const updateOutcomeNotice = () => {
        if (successCount === 0) {
          if (duplicateCount > 0 && errorCount === 0) {
            setBatchOutcomeNotice({
              type: 'duplicate',
              message: 'All QR codes you pasted were already captured for this order. No new packs were added.'
            })
          } else if (errorCount > 0 && duplicateCount === 0) {
            setBatchOutcomeNotice({
              type: 'error',
              message: 'None of the pasted QR codes belong to this order, so nothing was recorded.'
            })
          } else if (duplicateCount + errorCount > 0) {
            setBatchOutcomeNotice({
              type: 'mixed',
              message: 'Duplicates and invalid codes were skipped automatically, so nothing was recorded.'
            })
          }
        }
      }

      setBatchProcessingStatus('Batch scan complete!')
      setBatchProcessingSummary({
        total: uniqueCodes.length,
        success: successCount,
        duplicates: duplicateCount,
        errors: errorCount
      })
      setBatchProcessingProgress(100)
      updateOutcomeNotice()
      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1200)

      setBatchInput('')
      setShowBatchInput(false)
    }

    startBatch().catch(error => {
      console.error('Error during batch scan:', error)
      setBatchProcessingStatus('Batch scan interrupted. Please try again.')
      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1500)
    })
  }

  const handleMasterBatchAssign = () => {
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Auto assignment is disabled.',
        variant: 'destructive'
      })
      return
    }

    if (!masterBatchInput.trim()) {
      toast({
        title: 'Error',
        description: 'Paste the Excel export rows before processing.',
        variant: 'destructive'
      })
      return
    }

    const { entries, invalidLines, totalCases, totalUnique } = parseMasterBatchInput(masterBatchInput)

    if (entries.length === 0) {
      toast({
        title: 'No Master Cases Detected',
        description: 'Ensure each row includes a master code followed by at least one unique QR code.',
        variant: 'destructive'
      })
      return
    }

    let linkedCount = 0
    let skippedCount = 0
    let errorCount = 0
    let variantFilteredCount = 0

    const process = async () => {
      setBatchProcessingMode('master-link')
      setBatchProcessingSummary({
        total: totalCases,
        success: 0,
        duplicates: 0,
        errors: 0
      })
      setBatchProcessingProgress(0)
      setBatchProcessingStatus('Preparing auto-assignment...')
      setBatchProcessingActive(true)

      for (let index = 0; index < entries.length; index++) {
        const [master, codes] = entries[index]

        setBatchProcessingStatus(`Linking master case ${index + 1} of ${totalCases}`)

        try {
          const response = await fetch('/api/manufacturer/link-to-master', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              master_code: master,
              unique_codes: codes,
              manufacturer_org_id: userProfile.organization_id,
              user_id: userProfile.id,
              skip_case_validation: skipCaseValidation
            })
          })

          if (!response.ok) {
            const errorData = await response.json()
            const message = (errorData?.error || 'Failed to link master case') as string

            if (/already.+packed/i.test(message) || /already linked/i.test(message)) {
              skippedCount++
            } else {
              errorCount++
            }
          } else {
            const result = await response.json()
            linkedCount++

            // Track variant-filtered codes
            if (result.skipped_variant_count && result.skipped_variant_count > 0) {
              variantFilteredCount += result.skipped_variant_count
            }
          }
        } catch (error: any) {
          errorCount++
        }

        const progress = Math.round(((index + 1) / totalCases) * 100)
        setBatchProcessingProgress(progress)
        setBatchProcessingSummary({
          total: totalCases,
          success: linkedCount,
          duplicates: skippedCount,
          errors: errorCount
        })
        await new Promise(resolve => setTimeout(resolve, 100))
      }

      await loadProgress(selectedOrder)

      setMasterBatchInput('') // Unused in V2 but kept for compatibility
      setShowMasterBatchInput(false) // Unused in V2 but kept for compatibility

      setBatchProcessingStatus('Auto assignment complete!')
      setBatchProcessingSummary({
        total: totalCases,
        success: linkedCount,
        duplicates: skippedCount,
        errors: errorCount
      })
      setBatchProcessingProgress(100)
      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1500)

      if (invalidLines.length > 0) {
        toast({
          title: 'Some rows were skipped',
          description: `${invalidLines.length} line(s) could not be parsed. Ensure each row contains a master code and unique codes.`,
          variant: 'destructive'
        })
      }

      if (variantFilteredCount > 0) {
        toast({
          title: 'Variant Filtering Applied',
          description: `${variantFilteredCount} code(s) were automatically excluded during linking because they belonged to different product variants. These codes remain available in your buffer for master cases with matching variants.`,
        })
      }
    }

    process().catch(error => {
      console.error('Error during master batch assignment:', error)
      setBatchProcessingStatus('Auto assignment interrupted. Please review the data.')
      setTimeout(() => {
        setBatchProcessingActive(false)
        setBatchProcessingMode(null)
      }, 1500)
    })
  }

  const handleGenerateBulkMaster = async () => {
    if (packingMode !== 'bulk_generate') {
      return
    }

    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Automatic master creation is disabled.',
        variant: 'destructive'
      })
      return
    }

    if (!currentBatchProgress) {
      toast({
        title: 'No Batch Selected',
        description: 'Select an order with an active batch before generating master cases.',
        variant: 'destructive'
      })
      return
    }

    const targetUnits = Number(bulkTargetCount)
    if (!targetUnits || Number.isNaN(targetUnits) || targetUnits < 1) {
      toast({
        title: 'Set a Target First',
        description: 'Enter the expected number of units per master case before generating.',
        variant: 'destructive'
      })
      return
    }

    if (scannedCodes.length < targetUnits) {
      toast({
        title: 'Not Enough Codes Yet',
        description: `Scan ${targetUnits - scannedCodes.length} more unique code${targetUnits - scannedCodes.length === 1 ? '' : 's'} before generating a master case.`,
        variant: 'destructive'
      })
      return
    }

    const codesToLink = scannedCodes.slice(0, targetUnits)
    const remainingCodes = scannedCodes.slice(targetUnits)

    try {
      setBulkGenerating(true)
      const { data: nextMaster, error: masterLookupError } = await supabase
        .from('qr_master_codes')
        .select('id, master_code, case_number, expected_unit_count')
        .eq('batch_id', currentBatchProgress.batch_id)
        .eq('status', 'generated')
        .order('case_number', { ascending: true })
        .limit(1)
        .maybeSingle()

      if (masterLookupError) {
        throw masterLookupError
      }

      if (!nextMaster) {
        toast({
          title: 'No Available Master Cases',
          description: 'All master cases for this batch are already packed. Generate more via the Excel tool if needed.',
          variant: 'destructive'
        })
        return
      }

      if (nextMaster.expected_unit_count && codesToLink.length > nextMaster.expected_unit_count) {
        toast({
          title: 'Too Many Codes',
          description: `This master case expects ${nextMaster.expected_unit_count} units, but ${codesToLink.length} are selected. Remove extra codes and try again.`,
          variant: 'destructive'
        })
        return
      }

      const response = await fetch('/api/manufacturer/link-to-master', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          master_code: nextMaster.master_code,
          unique_codes: codesToLink.map(code => code.code),
          manufacturer_org_id: userProfile.organization_id,
          user_id: userProfile.id,
          skip_case_validation: true
        })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to generate master case')
      }

      const result = await response.json()

      setScannedCodes(remainingCodes)
      setRecentAutoMasters(prev => [
        {
          master_code: result.master_code_info.master_code,
          case_number: result.master_code_info.case_number,
          total_units: result.master_code_info.actual_units,
          created_at: new Date().toISOString()
        },
        ...prev
      ].slice(0, 5))

      const leftoverCount = remainingCodes.length
      toast({
        title: 'Master Case Created',
        description: `Generated Case #${result.master_code_info.case_number} with ${result.master_code_info.actual_units} units.${leftoverCount > 0 ? ` ${leftoverCount} code${leftoverCount === 1 ? '' : 's'} left in buffer.` : ''}`,
      })

      await loadProgress(selectedOrder)
    } catch (error: any) {
      console.error('Error generating master case automatically:', error)
      toast({
        title: 'Generation Failed',
        description: error.message || 'Unable to create master case automatically.',
        variant: 'destructive'
      })
    } finally {
      setBulkGenerating(false)
    }
  }

  const handleLinkToMaster = async () => {
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Linking changes are disabled.',
        variant: 'destructive'
      })
      return
    }

    if (!masterCode.trim() || scannedCodes.length === 0) {
      toast({
        title: 'Error',
        description: 'Please scan master code and at least one unique code',
        variant: 'destructive'
      })
      return
    }

    try {
      setLinking(true)
      const response = await fetch('/api/manufacturer/link-to-master', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          master_code: masterCode,
          unique_codes: scannedCodes.map(c => c.code),
          manufacturer_org_id: userProfile.organization_id,
          user_id: userProfile.id,
          skip_case_validation: skipCaseValidation
        })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to link codes')
      }

      const result = await response.json()
      const linkedCodes: string[] = result.linked_codes || []
      const unusedCodes: string[] = result.unused_codes || []
      const skippedVariantCodes: string[] = result.skipped_variant_codes || []
      const isComplete = Boolean(result.master_code_info?.is_complete)

      // Build success message with variant filtering info
      let description = `Successfully linked ${result.linked_count} code(s) to Case #${result.master_code_info.case_number}`

      if (result.master_code_info.variant_name) {
        description += ` (${result.master_code_info.variant_name})`
      }

      if (skippedVariantCodes.length > 0) {
        const skippedSummary = Object.entries(result.skipped_variant_summary || {})
          .map(([variant, count]) => `${count} ${variant}`)
          .join(', ')
        description += `.\n\n‚ö†Ô∏è ${skippedVariantCodes.length} code(s) were not linked because they belong to different variant(s): ${skippedSummary}. These codes remain in your buffer and can be linked to a master case with the matching variant.`
      } else if (unusedCodes.length > 0) {
        description += `.\n\n${unusedCodes.length} code(s) kept for the next case (capacity reached).`
      }

      toast({
        title: skippedVariantCodes.length > 0 ? 'Partially Linked' : 'Success',
        description,
      })

      // Remove only the linked codes from scanned codes
      setScannedCodes(prev => prev.filter(item => !linkedCodes.includes(item.code)))

      if (isComplete) {
        setMasterCode('')
      }

      loadProgress(selectedOrder)
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive'
      })
    } finally {
      setLinking(false)
    }
  }

  const handleMarkCasePerfect = async () => {
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Changes are disabled.',
        variant: 'destructive'
      })
      return
    }

    if (!masterCode.trim()) {
      toast({
        title: 'Error',
        description: 'Please scan the master case QR code',
        variant: 'destructive'
      })
      return
    }

    if (!currentBatchProgress || !currentBatchProgress.order_no) {
      toast({
        title: 'No order selected',
        description: 'Select an order from the top of the page before marking cases as perfect.',
        variant: 'destructive'
      })
      return
    }

    if (!selectedOrder) {
      toast({
        title: 'Missing order context',
        description: 'Please choose an order first. This prevents mixing master cases across orders.',
        variant: 'destructive'
      })
      return
    }

    if (scannedCodes.length > 0) {
      toast({
        title: 'Error',
        description: 'This feature is for perfect cases only. Your buffer has scanned codes. Please use "Link to Master Case" instead.',
        variant: 'destructive'
      })
      return
    }

    // Parse master codes (one per line)
    const inputCodes = masterCode.trim().split('\n').filter(line => line.trim())

    if (inputCodes.length === 0) {
      toast({
        title: 'Error',
        description: 'Please scan at least one master case QR code',
        variant: 'destructive'
      })
      return
    }

    // Validate QR code types - detect unique codes vs master codes
    const uniqueCodes: string[] = []
    const masterCodesSet = new Set<string>()
    const alreadyScannedCodes: string[] = []

    for (const code of inputCodes) {
      const cleanCode = code.trim()
      
      // Check if code looks like a unique product code (contains PROD- prefix typically)
      // Master codes usually end with -M or have different pattern
      if (cleanCode.includes('/track/product/PROD-') || 
          (cleanCode.includes('PROD-') && !cleanCode.endsWith('-M'))) {
        uniqueCodes.push(cleanCode)
      } else {
        // Extract the base master code (remove hash if present)
        const baseMasterCode = cleanCode.split('-').slice(0, -1).join('-')
        masterCodesSet.add(baseMasterCode || cleanCode)
      }
    }

    // Convert set back to array (now deduplicated)
    const validMasterCodes = Array.from(masterCodesSet)

    // Handle case: Only unique codes entered (user mistake)
    if (uniqueCodes.length > 0 && validMasterCodes.length === 0) {
      toast({
        title: 'Wrong QR Code Type',
        description: `You scanned ${uniqueCodes.length} unique product QR code${uniqueCodes.length > 1 ? 's' : ''}, not master case QR codes. Please scan the master case QR code instead.`,
        variant: 'destructive'
      })
      return
    }

    // Show info about deduplication if duplicates were removed
    const totalInputCodes = inputCodes.length
    const totalUniqueCodes = uniqueCodes.length
    const totalDuplicates = totalInputCodes - validMasterCodes.length - totalUniqueCodes
    
    if (totalDuplicates > 0) {
      toast({
        title: 'Duplicate Codes Removed',
        description: `Removed ${totalDuplicates} duplicate master code${totalDuplicates > 1 ? 's' : ''}. Processing ${validMasterCodes.length} unique master case${validMasterCodes.length > 1 ? 's' : ''}.`,
        variant: 'default'
      })
    }

    // Handle case: Mixed codes entered
    if (uniqueCodes.length > 0 && validMasterCodes.length > 0) {
      const proceed = window.confirm(
        `‚ö†Ô∏è Mixed QR Codes Detected\n\n` +
        `You entered:\n` +
        `‚Ä¢ ${validMasterCodes.length} unique master case QR code${validMasterCodes.length > 1 ? 's' : ''}\n` +
        `‚Ä¢ ${uniqueCodes.length} unique product QR code${uniqueCodes.length > 1 ? 's' : ''}\n\n` +
        `Do you want to proceed with only the master case QR codes?\n\n` +
        `(The unique product codes will be removed)`
      )

      if (!proceed) {
        return
      }

      // Show info toast about filtering
      toast({
        title: 'Codes Filtered',
        description: `Removed ${uniqueCodes.length} unique product code${uniqueCodes.length > 1 ? 's' : ''}. Processing ${validMasterCodes.length} master case code${validMasterCodes.length > 1 ? 's' : ''}.`,
        variant: 'default'
      })
    }

    // Validate that each master code belongs to the currently selected order
    const expectedOrderNo = currentBatchProgress.order_no.toUpperCase()
    const mismatchedOrderCodes: string[] = []
    const unknownOrderCodes: string[] = []

    if (expectedOrderNo) {
      for (const code of validMasterCodes) {
        const parsedOrder = extractOrderNumber(code)
        if (!parsedOrder) {
          unknownOrderCodes.push(code.trim())
          continue
        }

        if (parsedOrder.toUpperCase() !== expectedOrderNo) {
          mismatchedOrderCodes.push(code.trim())
        }
      }

      if (unknownOrderCodes.length > 0) {
        toast({
          title: 'Cannot read QR code order',
          description: `Unable to detect order number from ${unknownOrderCodes.length === 1 ? 'this master code' : 'some master codes'}. Please re-scan to ensure the QR is correct for ${expectedOrderNo}.`,
          variant: 'destructive'
        })
        return
      }

      if (mismatchedOrderCodes.length > 0) {
        toast({
          title: 'Wrong Order Selected',
          description: `${mismatchedOrderCodes.length === 1 ? 'This master code belongs' : 'These master codes belong'} to a different order. Current order: ${expectedOrderNo}. Please switch orders or rescan the correct QR.`,
          variant: 'destructive'
        })
        return
      }
    }

    // Check for already scanned master codes before API call
    try {
      setMarkingPerfect(true)
      
      // Pre-check: Query database to see which codes are already marked perfect
      const checkResponse = await fetch('/api/manufacturer/check-master-codes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          master_codes: validMasterCodes,
          manufacturer_org_id: userProfile.organization_id
        })
      })

      const { data: checkResult, rawText: checkRaw } = await readResponsePayload<any>(checkResponse)

      if (!checkResponse.ok) {
        console.error('Failed to verify master codes before mark-perfect:', checkRaw)
        throw new Error(
          (typeof checkResult?.error === 'string' && checkResult.error.trim().length > 0)
            ? checkResult.error
            : 'Unable to verify master codes before processing'
        )
      }

      let alreadyComplete: string[] = Array.isArray(checkResult?.already_complete)
        ? checkResult.already_complete
        : []

      // If all codes are already marked perfect, show message and exit
      if (alreadyComplete.length === validMasterCodes.length) {
        toast({
          title: 'Already Completed',
          description: `${alreadyComplete.length === 1 ? 'This master case has' : 'All master cases have'} already been marked as perfect. No changes needed.`,
          variant: 'default'
        })
        setMarkingPerfect(false)
        setMasterCode('')
        return
      }

      // If some codes already complete, show warning and ask to proceed
      if (alreadyComplete.length > 0) {
        const proceed = window.confirm(
          `‚ö†Ô∏è Some Codes Already Scanned\n\n` +
          `${alreadyComplete.length} out of ${validMasterCodes.length} master case${validMasterCodes.length > 1 ? 's have' : ' has'} already been marked as perfect.\n\n` +
          `Do you want to proceed with the remaining ${validMasterCodes.length - alreadyComplete.length} code${validMasterCodes.length - alreadyComplete.length > 1 ? 's' : ''}?`
        )

        if (!proceed) {
          setMarkingPerfect(false)
          return
        }
      }

      const startTime = Date.now()

      let successCount = 0
      let failedCodes: string[] = []
      let notFoundCodes: string[] = []
      let duplicateCodes: string[] = []
      let workerProcessedCodes: string[] = []
      let totalLinked = 0

      // Process each master code
      for (const code of validMasterCodes) {
        try {
          const response = await fetch('/api/manufacturer/mark-case-perfect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              master_code: code.trim(),
              manufacturer_org_id: userProfile.organization_id,
              user_id: userProfile.id,
              order_id: selectedOrder // Pass current order for validation
            })
          })

          const { data: responseData, rawText } = await readResponsePayload<any>(response)

          if (!response.ok) {
            const sanitizedRaw = rawText ? rawText.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim() : ''
            const fallbackErrorMessage = sanitizedRaw ? sanitizedRaw.slice(0, 180) : 'Failed to mark case as perfect'
            const errorMessage = typeof responseData?.error === 'string' && responseData.error.trim().length > 0
              ? responseData.error
              : fallbackErrorMessage
            const normalizedError = errorMessage.toUpperCase()
            const detailedMessage = typeof responseData?.message === 'string' && responseData.message.trim().length > 0
              ? responseData.message
              : fallbackErrorMessage
            const rawLowerCase = sanitizedRaw.toLowerCase()
            
            // Categorize errors for better user feedback
            if (normalizedError === 'WORKER_PROCESSED') {
              // This case has been processed by workers - cannot use Mark Perfect
              workerProcessedCodes.push(code.trim())
              console.warn(`Case already processed by workers: ${code.trim()}`)
            } else if (normalizedError === 'WRONG_ORDER') {
              // Wrong order - show detailed message from API
              toast({
                title: 'Wrong Order',
                description: detailedMessage || 'This master case belongs to a different order',
                variant: 'destructive'
              })
              setMarkingPerfect(false)
              return // Stop processing
            } else if (errorMessage.toLowerCase().includes('not found')) {
              notFoundCodes.push(code.trim())
            } else if (errorMessage.toLowerCase().includes('already')) {
              duplicateCodes.push(code.trim())
            } else if (rawLowerCase.includes('cloudflare')) {
              toast({
                title: 'Request blocked (Cloudflare)',
                description: 'Security protection temporarily blocked this action. Please wait a few seconds and try again.',
                variant: 'destructive'
              })
              setMarkingPerfect(false)
              return
            } else {
              failedCodes.push(code.trim())
            }
            
            console.error(`Failed to mark ${code}:`, errorMessage, sanitizedRaw)
            continue
          }

          if (!responseData) {
            console.error('Empty response when marking case perfect. Raw response:', rawText)
            failedCodes.push(code.trim())
            continue
          }

          const result = responseData
          
          // Check if case was already completed
          if (result.already_complete) {
            duplicateCodes.push(code.trim())
            console.warn(`Master code already marked perfect: ${code.trim()}`)
          } else {
            successCount++
            totalLinked += result.linked_count || 0
          }
        } catch (error: any) {
          console.error(`Failed to mark ${code}:`, error)
          // Check if this is a network/fetch error
          if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
            toast({
              title: 'Connection Error',
              description: 'Unable to connect to server. Please check your internet connection and try again.',
              variant: 'destructive'
            })
            setMarkingPerfect(false)
            return // Stop processing on network error
          }
          failedCodes.push(code.trim())
        }
      }

      const endTime = Date.now()
      const duration = endTime - startTime

      // Show summary toast with human-friendly messages
      if (workerProcessedCodes.length > 0 && successCount === 0 && duplicateCodes.length === 0 && notFoundCodes.length === 0) {
        // All codes were processed by workers - CRITICAL ERROR
        toast({
          title: '‚ö†Ô∏è Cannot Use Mark Perfect',
          description: workerProcessedCodes.length === 1
            ? 'This case has already been processed by workers using the scanning system. You cannot use Mark Perfect on cases that have scan history, as it would overwrite the worker\'s actual scanning data.'
            : `${workerProcessedCodes.length} cases have already been processed by workers. Mark Perfect can only be used for truly perfect cases that have never been scanned by workers.`,
          variant: 'destructive'
        })
      } else if (notFoundCodes.length > 0 && successCount === 0 && duplicateCodes.length === 0 && workerProcessedCodes.length === 0) {
        // All codes are invalid/not found
        toast({
          title: 'Invalid QR Codes',
          description: notFoundCodes.length === 1 
            ? 'This is not a valid master case QR code. Please scan the master case QR code from the case label.'
            : `${notFoundCodes.length} QR codes are not valid master case codes. Please scan master case QR codes from the case labels.`,
          variant: 'destructive'
        })
      } else if (duplicateCodes.length === validMasterCodes.length) {
        // All codes were already marked perfect
        toast({
          title: 'Already Completed',
          description: `${duplicateCodes.length === 1 ? 'This master case has' : `All ${duplicateCodes.length} master cases have`} already been marked as perfect. No changes needed.`,
          variant: 'default'
        })
      } else if (successCount === validMasterCodes.length) {
        // All success
        toast({
          title: '‚úÖ Perfect Cases Marked!',
          description: `Successfully marked ${successCount} case${successCount > 1 ? 's' : ''} as perfect with ${totalLinked} total codes auto-linked.`,
        })
      } else if (successCount > 0) {
        // Partial success - show detailed breakdown
        const failureDetails: string[] = []
        if (workerProcessedCodes.length > 0) {
          failureDetails.push(`${workerProcessedCodes.length} already processed by workers`)
        }
        if (duplicateCodes.length > 0) {
          failureDetails.push(`${duplicateCodes.length} already marked`)
        }
        if (notFoundCodes.length > 0) {
          failureDetails.push(`${notFoundCodes.length} invalid code${notFoundCodes.length > 1 ? 's' : ''}`)
        }
        if (failedCodes.length > 0) {
          failureDetails.push(`${failedCodes.length} failed`)
        }

        toast({
          title: 'Partial Success',
          description: `Marked ${successCount}/${validMasterCodes.length} cases as perfect. ${failureDetails.join(', ')}.`,
          variant: 'default'
        })
      } else {
        // All failed - provide helpful guidance
        let errorMessage = 'Unable to mark cases as perfect. '
        if (workerProcessedCodes.length > 0) {
          errorMessage += `${workerProcessedCodes.length} case${workerProcessedCodes.length > 1 ? 's have' : ' has'} already been processed by workers (cannot use Mark Perfect). `
        }
        if (notFoundCodes.length > 0) {
          errorMessage += 'Some QR codes are not valid master case codes. '
        }
        if (duplicateCodes.length > 0) {
          errorMessage += 'Some cases were already marked perfect. '
        }
        errorMessage += 'Please check and try again.'

        toast({
          title: 'Cannot Process',
          description: errorMessage,
          variant: 'destructive'
        })
      }

      // Show timing summary (only for newly processed cases)
      if (successCount > 0) {
        setMarkPerfectTiming({
          duration,
          casesProcessed: successCount,
          totalLinked
        })

        // Auto-dismiss after 30 seconds
        setTimeout(() => {
          setMarkPerfectTiming(null)
        }, 30000)
      }

      setMasterCode('')
      loadProgress(selectedOrder)
    } catch (error: any) {
      console.error('Mark Perfect error:', error)
      // Better error messages for common issues
      let errorTitle = 'Error'
      let errorDescription = error.message || 'An unexpected error occurred'
      
      if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
        errorTitle = 'Connection Error'
        errorDescription = 'Unable to connect to server. Please check your internet connection and try again.'
      } else if (error.message?.includes('network') || error.message?.includes('timeout')) {
        errorTitle = 'Network Error'
        errorDescription = 'Request timed out. Please check your connection and try again.'
      }
      
      toast({
        title: errorTitle,
        description: errorDescription,
        variant: 'destructive'
      })
    } finally {
      setMarkingPerfect(false)
    }
  }

  const handleRemoveCode = (index: number) => {
    setScannedCodes(prev => prev.filter((_, i) => i !== index))
  }

  const handleUnlinkMaster = async (masterCodeId: string, caseNumber: number) => {
    if (isOrderLocked) {
      toast({
        title: 'Order locked',
        description: 'Warehouse intake has begun for this order. Master cases can no longer be unlinked.',
        variant: 'destructive'
      })
      return
    }

    if (!confirm(`Are you sure you want to unlink Case #${caseNumber}? This will reset all unique codes back to unscanned state.`)) {
      return
    }

    try {
      setUnlinking(masterCodeId)
      const response = await fetch('/api/manufacturer/unlink-master', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          master_code_id: masterCodeId,
          user_id: userProfile.id
        })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to unlink master case')
      }

      const result = await response.json()

      toast({
        title: 'Success',
        description: result.message || `Successfully unlinked Case #${caseNumber}`,
      })

      loadProgress(selectedOrder)
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive'
      })
    } finally {
      setUnlinking(null)
    }
  }

  const handleDownloadScanSummary = async () => {
    if (!currentBatchProgress) {
      toast({
        title: 'Error',
        description: 'No active batch to export',
        variant: 'destructive'
      })
      return
    }

    try {
      setDownloadingExcel(true)

      const response = await fetch(`/api/manufacturer/scan-summary-excel?batch_id=${currentBatchProgress.batch_id}`)

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to generate Excel file')
      }

      // Get the blob from response
      const blob = await response.blob()

      // Create a download link
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `Scan_Summary_${currentBatchProgress.batch_code}_${new Date().toISOString().split('T')[0]}.xlsx`
      document.body.appendChild(a)
      a.click()

      // Cleanup
      window.URL.revokeObjectURL(url)
      document.body.removeChild(a)

      toast({
        title: 'Success',
        description: 'Scan summary Excel file downloaded successfully',
      })
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive'
      })
    } finally {
      setDownloadingExcel(false)
    }
  }

  const handleCompleteProduction = async () => {
    if (!currentBatchProgress) {
      toast({
        title: 'Error',
        description: 'No active batch selected',
        variant: 'destructive'
      })
      return
    }

    // Check if production is ready to be completed (must be 100%)
    const progressPercent = currentBatchProgress.master_progress_percentage || 0

    if (progressPercent < 100) {
      toast({
        title: 'Cannot Complete Production',
        description: `Production must be 100% complete. Current progress: ${progressPercent.toFixed(1)}%`,
        variant: 'destructive'
      })
      return
    }

    try {
      setCompletingProduction(true)

      const response = await fetch('/api/manufacturer/complete-production', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          batch_id: currentBatchProgress.batch_id
        })
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to complete production')
      }

      const result = await response.json()

      // Calculate balance percentage from payment terms
      const selectedOrderData = orders.find(o => o.id === selectedOrder)
      const balancePct = selectedOrderData?.payment_terms?.balance_pct || 0.5
      const balancePercentage = Math.round(balancePct * 100)

      // Show success message with balance payment info
      const balanceMessage = result.balance_payment_created 
        ? ` Balance payment request (${balancePercentage}%) has been sent to admin for approval.`
        : ''

      toast({
        title: 'Production Complete! üéâ',
        description: `Batch ${currentBatchProgress.batch_code} is now ready for warehouse shipment. ${result.packed_master_codes} of ${result.total_master_codes} cases packed.${balanceMessage}`,
      })

      // Refresh batch progress to show updated status
      await Promise.all([
        loadProgress(selectedOrder),
        loadOrders()
      ])
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive'
      })
    } finally {
      setCompletingProduction(false)
    }
  }

  const DonutProgress = ({ value, label, size = 'md' }: { value: number; label: string; size?: 'sm' | 'md' }) => {
    const clamped = Math.max(0, Math.min(100, Number.isFinite(value) ? value : 0))
    const angle = clamped * 3.6

    const sizeClasses = size === 'sm'
      ? { container: 'h-20 w-20', inset: 'inset-[10px]', text: 'text-lg', gap: 'gap-2' }
      : { container: 'h-28 w-28', inset: 'inset-[14px]', text: 'text-xl', gap: 'gap-3' }

    return (
      <div className={`flex flex-col items-center ${sizeClasses.gap}`}>
        <div className={`relative ${sizeClasses.container}`}>
          <div
            className="absolute inset-0 rounded-full"
            style={{
              background: `conic-gradient(#1d4ed8 ${angle}deg, #e5e7eb ${angle}deg)`
            }}
          />
          <div className={`absolute ${sizeClasses.inset} rounded-full bg-white flex items-center justify-center shadow-inner`}>
            <span className={`${sizeClasses.text} font-semibold text-blue-700`}>{clamped}%</span>
          </div>
        </div>
        <p className="text-xs font-medium text-gray-700 text-center">{label}</p>
      </div>
    )
  }

  const renderStatusBadge = (status?: string | null): JSX.Element => {
    switch (status) {
      case 'generated':
        return (
          <Badge variant="secondary" className="bg-amber-100 text-amber-900 border-amber-200">
            In Progress
          </Badge>
        )
      case 'packed':
        return (
          <Badge variant="default" className="bg-green-600">
            <CheckCircle className="h-3 w-3 mr-1" />
            Packed
          </Badge>
        )
      case 'ready_to_ship':
        return (
          <Badge variant="default" className="bg-emerald-600">
            <CheckCircle className="h-3 w-3 mr-1" />
            Ready to Ship
          </Badge>
        )
      case 'pending':
        return (
          <Badge variant="secondary" className="bg-amber-100 text-amber-900 border-amber-200">
            In Progress
          </Badge>
        )
      case 'received_warehouse':
        return (
          <Badge variant="default" className="bg-blue-600">
            Received at Warehouse
          </Badge>
        )
      case 'shipped_distributor':
        return (
          <Badge variant="default" className="bg-purple-600">
            Shipped to Distributor
          </Badge>
        )
      case 'opened':
        return (
          <Badge variant="default" className="bg-slate-700">
            Case Opened
          </Badge>
        )
      default:
        return (
          <Badge variant="secondary" className="uppercase">
            {status || 'Unknown'}
          </Badge>
        )
    }
  }

  const uniqueScanCard = (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Scan className="h-5 w-5" />
          {packingMode === 'bulk_generate' ? 'Capture Unique QR Codes' : 'Scan Unique QR Codes'}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {isOrderLocked && (
          <Alert className="border-amber-200 bg-amber-50 text-amber-900">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              Warehouse intake has begun for this order. Scanning is paused until receiving is complete.
            </AlertDescription>
          </Alert>
        )}
        {renderBatchOutcomeNotice()}
        {packingMode === 'bulk_generate' && (
          <div className="rounded-lg border border-blue-200 bg-blue-50 p-3 text-sm text-blue-700">
            Scan the unique packs that belong in the next master case. When you hit the target count, create the case automatically on the right.
          </div>
        )}

        {/* Batch Scan Mode Selection - Always Visible */}
        <div className="bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-lg p-4 space-y-3">
          <div className="flex items-center gap-2 mb-2">
            <Package className="h-5 w-5 text-indigo-600" />
            <label className="block text-sm font-bold text-gray-900">
              Batch Scan Mode
            </label>
          </div>
          <div className="grid grid-cols-2 gap-3">
            <button
              onClick={() => setBatchScanMode('normal')}
              disabled={isOrderLocked}
              className={`px-4 py-3 rounded-lg border-2 transition-all text-left ${batchScanMode === 'normal'
                ? 'border-blue-500 bg-blue-50 shadow-sm'
                : 'border-gray-200 bg-white hover:border-gray-300'
                } ${isOrderLocked ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
            >
              <div className="flex items-center gap-2 mb-1">
                <div className={`w-4 h-4 rounded-full border-2 flex items-center justify-center ${batchScanMode === 'normal' ? 'border-blue-500' : 'border-gray-300'
                  }`}>
                  {batchScanMode === 'normal' && (
                    <div className="w-2 h-2 rounded-full bg-blue-500"></div>
                  )}
                </div>
                <span className="font-semibold text-sm">Mode A - Normal</span>
              </div>
              <p className="text-xs text-gray-600 ml-6">
                Scan/paste 50 QR codes to <strong>include</strong> in the master case
              </p>
            </button>

            <button
              onClick={() => setBatchScanMode('async_reverse')}
              disabled={isOrderLocked}
              className={`px-4 py-3 rounded-lg border-2 transition-all text-left ${batchScanMode === 'async_reverse'
                ? 'border-green-500 bg-green-50 shadow-sm'
                : 'border-gray-200 bg-white hover:border-gray-300'
                } ${isOrderLocked ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
            >
              <div className="flex items-center gap-2 mb-1">
                <div className={`w-4 h-4 rounded-full border-2 flex items-center justify-center ${batchScanMode === 'async_reverse' ? 'border-green-500' : 'border-gray-300'
                  }`}>
                  {batchScanMode === 'async_reverse' && (
                    <div className="w-2 h-2 rounded-full bg-green-500"></div>
                  )}
                </div>
                <span className="font-semibold text-sm">Mode B - Smart Scan</span>
              </div>
              <p className="text-xs text-gray-600 ml-6">
                Smart QR Validation & Replacement
              </p>
            </button>
          </div>
          <div className="text-xs text-gray-600 bg-white rounded p-2 border border-gray-200">
            <strong>Current Mode:</strong> {
              batchScanMode === 'normal'
                ? 'Mode A - Normal (Include 50 codes)'
                : 'Mode B - Smart Scan (Smart QR Validation & Replacement)'
            }
          </div>
        </div>

        {/* Mode C - Smart Scan */}
        {batchScanMode === 'async_reverse' ? (
          <ModeCReverseCaseView
            currentBatchProgress={currentBatchProgress}
            userProfile={userProfile}
            isOrderLocked={isOrderLocked}
            onJobComplete={() => {
              if (selectedOrder) {
                // Small delay to ensure database transaction commits
                setTimeout(() => {
                  loadProgress(selectedOrder)
                }, 500)
              }
            }}
          />
        ) : (
          <>
            {/* Mode A - Normal Scan UI */}
            <div>
              <Button
                variant="outline"
                onClick={() => setShowBatchInput(!showBatchInput)}
                className="w-full"
                disabled={isOrderLocked}
              >
                <ClipboardPaste className="h-4 w-4 mr-2" />
                {showBatchInput ? 'Hide' : 'Show'} Batch Paste
              </Button>
            </div>

            {showBatchInput && (
              <div className="border border-blue-200 rounded-lg p-4 bg-blue-50 space-y-3">
                <label className="block text-sm font-medium text-gray-700">
                  Paste Multiple QR Codes (one per line)
                </label>

                <textarea
                  value={batchInput}
                  onChange={(e) => setBatchInput(e.target.value)}
                  placeholder="Paste QR codes here... (one per line)&#10;PROD-ZEREL6829-MAN-552896-ORD-HM-1025-03-00001&#10;PROD-ZEREL6829-MAN-552896-ORD-HM-1025-03-00002&#10;..."
                  rows={6}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 font-mono text-xs"
                  disabled={isOrderLocked}
                />
                <div className="flex gap-2">
                  <Button
                    onClick={handleBatchPaste}
                    disabled={!batchInput.trim() || isOrderLocked}
                    className="flex-1"
                  >
                    <ClipboardPaste className="h-4 w-4 mr-2" />
                    Process Batch
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => setBatchInput('')}
                    disabled={isOrderLocked}
                  >
                    Clear
                  </Button>
                </div>
                <div className="text-xs text-gray-600">
                  {uniqueBatchStats.totalCodes > 0 ? (
                    <span>
                      Detected <strong>{uniqueBatchStats.totalCodes}</strong> QR codes (
                      <strong>{uniqueBatchStats.uniqueCodes}</strong> unique across {uniqueBatchStats.lines} line{uniqueBatchStats.lines === 1 ? '' : 's'}).
                    </span>
                  ) : (
                    <span>
                      Paste QR codes above to preview how many will be processed.
                    </span>
                  )}
                </div>
              </div>
            )}
          </>
        )}

        {/* Scanned Codes - Show for Mode A & B only */}
        {batchScanMode !== 'async_reverse' && (
          <div>
            <div className="flex items-center justify-between mb-2">
              <label className="text-sm font-medium text-gray-700">
                Scanned Codes ({scannedCodes.length})
              </label>
              {scannedCodes.length > 0 && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setScannedCodes([])}
                  disabled={isOrderLocked}
                >
                  Clear All
                </Button>
              )}
            </div>

            <div className="border border-gray-200 rounded-lg max-h-96 overflow-y-auto">
              {scannedCodes.length === 0 ? (
                <div className="p-8 text-center text-gray-500">
                  <QrCode className="h-12 w-12 mx-auto mb-2 text-gray-400" />
                  <p>No codes scanned yet</p>
                  <p className="text-sm">Scan QR codes to begin</p>
                </div>
              ) : (
                <div className="divide-y divide-gray-200">
                  {scannedCodes.map((code, index) => (
                    <div key={index} className="p-3 flex items-center justify-between hover:bg-gray-50">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <Badge variant="secondary" className="text-xs">
                            #{code.sequence_number}
                          </Badge>
                          <p className="text-sm font-medium text-gray-900">
                            {code.product_name}
                          </p>
                        </div>
                        <p className="text-xs text-gray-500">
                          {code.variant_name}
                        </p>
                        <p className="text-xs text-gray-400 font-mono mt-1">
                          {code.code}
                        </p>
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleRemoveCode(index)}
                        disabled={isOrderLocked}
                      >
                        <Trash2 className="h-4 w-4 text-red-600" />
                      </Button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )

  const manualLinkCard = (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2">
          <Package className="h-5 w-5" />
          Link to Master Case
        </CardTitle>
        {currentBatchProgress?.order_no && (
          <p className="text-xs text-gray-600 mt-1">
            Working on : <span className="font-semibold uppercase">{currentBatchProgress.order_no}</span>
          </p>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {isOrderLocked && (
          <Alert className="border-amber-200 bg-amber-50 text-amber-900">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              Warehouse intake has begun for this order. Linking changes are temporarily disabled.
            </AlertDescription>
          </Alert>
        )}
        <div>
          <div className="flex items-center justify-between mb-2">
            <label className="block text-sm font-medium text-gray-700">
              Master Case QR Code
            </label>
            {masterCode.trim() && (
              <Button
                onClick={() => setMasterCode('')}
                variant="outline"
                size="sm"
                className="text-xs h-7"
                disabled={isOrderLocked}
              >
                <XCircle className="h-3 w-3 mr-1" />
                Clear
              </Button>
            )}
          </div>
          <textarea
            value={masterCode}
            onChange={(e) => setMasterCode(e.target.value)}
            placeholder="Scan master case QR code... (one per line for multiple)"
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-vertical"
            rows={3}
            disabled={isOrderLocked}
          />
          {masterCode.trim().split('\n').filter(line => line.trim()).length > 0 && (
            <p className="text-xs text-blue-600 mt-1">
              ‚úì {masterCode.trim().split('\n').filter(line => line.trim()).length} master code{masterCode.trim().split('\n').filter(line => line.trim()).length > 1 ? 's' : ''} detected
            </p>
          )}
        </div>

        {/* "Show Master Case Batch Assign" button removed in V2 - simplified workflow */}
        {/* Unique Codes & Master Codes summary removed - simplified workflow */}

        <div className="w-full space-y-2">
          <Button
            onClick={handleMarkCasePerfect}
            disabled={markingPerfect || !masterCode || scannedCodes.length > 0 || isOrderLocked}
            variant="default"
            className="w-full bg-green-600 hover:bg-green-700 text-white"
            size="lg"
          >
            {markingPerfect ? (
              <>
                <RefreshCw className="h-5 w-5 mr-2 animate-spin" />
                Marking...
              </>
            ) : (
              <>
                <CheckCircle className="h-5 w-5 mr-2" />
                Mark Perfect
              </>
            )}
          </Button>

          {/* Timing Summary - Auto-dismisses after 30 seconds */}
          {markPerfectTiming && (
            <div className="mt-3 rounded-lg border border-green-200 bg-green-50 p-3 animate-in fade-in slide-in-from-top-2 duration-300">
              <div className="flex items-start gap-2">
                <CheckCircle className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
                <div className="flex-1 text-sm">
                  <p className="font-semibold text-green-900">
                    Process completed successfully
                  </p>
                  <div className="mt-1 space-y-0.5 text-xs text-green-700">
                    <p>‚è±Ô∏è Time taken: <span className="font-semibold">{formatProcessingDuration(markPerfectTiming.duration)}</span></p>
                    <p>üì¶ Cases processed: <span className="font-semibold">{markPerfectTiming.casesProcessed}</span></p>
                    <p>üîó Codes linked: <span className="font-semibold">{markPerfectTiming.totalLinked.toLocaleString()}</span></p>
                  </div>
                  <p className="mt-2 text-xs text-green-600 italic">
                    This message will disappear in 30 seconds
                  </p>
                </div>
                <button
                  onClick={() => setMarkPerfectTiming(null)}
                  className="text-green-600 hover:text-green-800 transition-colors"
                  aria-label="Dismiss"
                >
                  <XOctagon className="h-4 w-4" />
                </button>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )

  const readyToAssignCount = bulkTargetCount > 0
    ? Math.min(scannedCodes.length, bulkTargetCount)
    : scannedCodes.length
  const bufferedCount = bulkTargetCount > 0
    ? Math.max(scannedCodes.length - bulkTargetCount, 0)
    : 0

  const bulkFinalizeCard = (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Package className="h-5 w-5" />
          Generate Master Case Automatically
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {isOrderLocked && (
          <Alert className="border-amber-200 bg-amber-50 text-amber-900">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              Warehouse intake has begun for this order. Automatic master creation is disabled until receiving is complete.
            </AlertDescription>
          </Alert>
        )}
        <div className="rounded-lg border border-blue-200 bg-blue-50 p-4 space-y-2">
          <p className="text-sm text-blue-900 font-medium">
            Target per master case
          </p>
          <p className="text-xs text-blue-700">
            {expectedUnitsPerCase ? (
              <>Suggested: {expectedUnitsPerCase} units (based on batch plan). Adjust if this case should hold a different quantity.</>
            ) : (
              <>Set the number of unique units that should be inside each master case.</>
            )}
          </p>
          <input
            type="number"
            min={1}
            value={bulkTargetCount || ''}
            onChange={(e) => setBulkTargetCount(Number(e.target.value))}
            className="w-full rounded-lg border border-blue-300 px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500"
            placeholder="Units per master case"
            disabled={isOrderLocked}
          />
        </div>

        <div className="grid grid-cols-2 gap-3 text-sm">
          <div className="rounded-lg border border-gray-200 bg-gray-50 p-3">
            <p className="text-xs text-gray-500 uppercase">Ready to assign</p>
            <p className="text-xl font-semibold text-gray-900">{readyToAssignCount}</p>
          </div>
          <div className="rounded-lg border border-gray-200 bg-gray-50 p-3">
            <p className="text-xs text-gray-500 uppercase">Remaining in buffer</p>
            <p className="text-xl font-semibold text-gray-900">{bufferedCount}</p>
          </div>
        </div>

        <Button
          onClick={handleGenerateBulkMaster}
          disabled={bulkGenerating || bulkTargetCount <= 0 || scannedCodes.length < bulkTargetCount || isOrderLocked}
          className="w-full"
          size="lg"
        >
          {bulkGenerating ? (
            <>
              <RefreshCw className="mr-2 h-5 w-5 animate-spin" />
              Creating master case...
            </>
          ) : (
            <>
              <Package className="mr-2 h-5 w-5" />
              Create Master Case Now
            </>
          )}
        </Button>

        <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
          <h4 className="text-sm font-medium text-gray-900 mb-2">How it works</h4>
          <ol className="text-sm text-gray-600 space-y-1 list-decimal list-inside">
            <li>Scan unique codes on the left until you reach the target count.</li>
            <li>Click &quot;Create Master Case&quot; ‚Äî we will claim the next pending master QR.</li>
            <li>The case is packed, remaining scans stay in the buffer for the next case.</li>
          </ol>
        </div>

        {recentAutoMasters.length > 0 && (
          <div className="rounded-lg border border-green-200 bg-green-50 p-3 space-y-2">
            <p className="text-sm font-medium text-green-800 flex items-center gap-2">
              <CheckCircle className="h-4 w-4" />
              Recent automatic cases
            </p>
            <div className="space-y-1 text-xs text-green-800">
              {recentAutoMasters.map((item, index) => (
                <div key={`${item.master_code}-${index}`} className="flex items-center justify-between">
                  <span className="font-medium">Case #{item.case_number}</span>
                  <span>{item.total_units} units ‚Ä¢ {new Date(item.created_at).toLocaleTimeString()}</span>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )

  const planImportCard = (
    <Card className="lg:col-span-2">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <ClipboardPaste className="h-5 w-5" />
          Import Packing Plan Mapping
        </CardTitle>
        <p className="text-sm text-gray-500">
          Paste the rows from the planning spreadsheet. Each line should contain a master case followed by its child codes ‚Äî the system will validate and link them in bulk.
        </p>
      </CardHeader>
      <CardContent className="space-y-4">
        {isOrderLocked && (
          <Alert className="border-amber-200 bg-amber-50 text-amber-900">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              Warehouse intake has begun for this order. Importing plans is disabled until receiving is complete.
            </AlertDescription>
          </Alert>
        )}
        <div className="border border-purple-200 rounded-lg p-4 bg-purple-50 space-y-3">
          <label className="block text-sm font-medium text-gray-700">
            Paste Master ‚Üí Unique Mapping
          </label>
          <textarea
            value={masterBatchInput}
            onChange={(e) => setMasterBatchInput(e.target.value)}
            placeholder="MASTER-CASE-QR-0001,PROD-...-00001,PROD-...-00002&#10;MASTER-CASE-QR-0002\tPROD-...-00011\tPROD-...-00012"
            rows={7}
            className="w-full px-3 py-2 border border-purple-200 rounded-lg focus:ring-2 focus:ring-purple-500 font-mono text-xs bg-white"
            disabled={isOrderLocked}
          />
          <div className="flex flex-col sm:flex-row gap-2">
            <Button
              onClick={handleMasterBatchAssign}
              disabled={!masterBatchInput.trim() || isOrderLocked}
              className="flex-1"
            >
              <LinkIcon className="h-4 w-4 mr-2" />
              Auto Assign from Mapping
            </Button>
            <Button
              variant="outline"
              onClick={() => setMasterBatchInput('')}
              disabled={isOrderLocked}
            >
              Clear
            </Button>
          </div>
          <div className="text-xs text-purple-700">

            {masterBatchPreview.totalCases > 0 ? (
              <span>
                Ready to link <strong>{masterBatchPreview.totalCases}</strong> master case{masterBatchPreview.totalCases === 1 ? '' : 's'} covering{' '}
                <strong>{masterBatchPreview.totalUnique}</strong> child QR codes.
                {masterBatchPreview.invalidLines.length > 0 && (
                  <span className="text-amber-700">
                    {' '}
                    ({masterBatchPreview.invalidLines.length} line{masterBatchPreview.invalidLines.length === 1 ? '' : 's'} skipped as headers/invalid.)
                  </span>
                )}
              </span>
            ) : (
              <span>Paste exported rows to preview how many cases will be auto-assigned.</span>
            )}
          </div>
          <p className="text-xs text-purple-700">
            Tip: Copy rows directly from the generated Excel file ‚Äî headers will be ignored automatically.
          </p>
        </div>

        <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
          <h4 className="text-sm font-medium text-gray-900 mb-2">Plan import workflow</h4>
          <ol className="text-sm text-gray-600 space-y-1 list-decimal list-inside">
            <li>Generate or receive the packing plan spreadsheet.</li>
            <li>Copy the rows (master code + child codes) and paste them here.</li>
            <li>Click auto-assign to let the system validate, link, and mark master cases instantly.</li>
          </ol>
        </div>
      </CardContent>
    </Card>
  )
  return (
    <div className="space-y-6 relative">
      {batchProcessingActive && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-white/80 backdrop-blur-sm">
          <div className="bg-white shadow-2xl rounded-2xl p-8 w-full max-w-md space-y-6 border border-blue-100">
            <div className="space-y-2 text-center">
              <h3 className="text-xl font-semibold text-gray-900">
                {batchProcessingMode === 'master-link' ? 'Auto Assigning Master Cases' : 'Processing Batch'}
              </h3>
              <p className="text-sm text-gray-600">{batchProcessingStatus}</p>
              <p className="text-xs text-gray-400 uppercase tracking-wide">
                {batchProcessingSummary.success} of {batchProcessingSummary.total}{' '}
                {batchProcessingMode === 'master-link' ? 'cases linked' : 'codes scanned'}
              </p>
            </div>
            <Progress value={batchProcessingProgress} className="h-3" />
            <div className="grid grid-cols-3 gap-3 text-center text-sm">
              <div className="bg-blue-50 rounded-lg py-3">
                <p className="text-xs text-blue-700 uppercase tracking-wide">
                  {batchProcessingMode === 'master-link' ? 'Linked' : 'Success'}
                </p>
                <p className="text-lg font-semibold text-blue-900">{batchProcessingSummary.success}</p>
              </div>
              <div className="bg-amber-50 rounded-lg py-3">
                <p className="text-xs text-amber-700 uppercase tracking-wide">
                  {batchProcessingMode === 'master-link' ? 'Skipped' : 'Duplicates'}
                </p>
                <p className="text-lg font-semibold text-amber-900">{batchProcessingSummary.duplicates}</p>
              </div>
              <div className="bg-rose-50 rounded-lg py-3">
                <p className="text-xs text-rose-700 uppercase tracking-wide">Errors</p>
                <p className="text-lg font-semibold text-rose-900">{batchProcessingSummary.errors}</p>
              </div>
            </div>
          </div>
        </div>
      )}

      <div>
        <h1 className="text-3xl font-bold text-gray-900">Smart Scan</h1>
        <p className="text-gray-600 mt-1">
          Scan unique QR codes and link them to master case codes
        </p>
      </div>

      <Card className="bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-200">
        <CardContent className="p-4">
          <div className="flex items-center gap-4">
            <Target className="h-5 w-5 text-blue-600" />
            <div className="flex-1">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Select Order to Track Progress
              </label>
              <select
                value={selectedOrder}
                onChange={(e) => setSelectedOrder(e.target.value)}
                className="w-full px-4 py-2 border border-blue-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white"
              >
                <option value="">All Orders</option>
                {orders.map(order => (
                  <option key={order.id} value={order.id}>
                    {order.order_no} - {Array.isArray(order.organizations)
                      ? order.organizations[0]?.org_name
                      : order.organizations?.org_name}
                  </option>
                ))}
              </select>
            </div>
          </div>
        </CardContent>
      </Card>

      {currentBatchProgress && (
        <Card className="border-green-200 bg-green-50">
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle className="flex items-center gap-2 text-green-900">
                <TrendingUp className="h-5 w-5" />
                Current Batch Progress: {currentBatchProgress.batch_code}
              </CardTitle>
              {/* Live updates toggle for testing */}
              <div className="flex items-center gap-2">
                {autoRefreshEnabled ? (
                  <div className="text-xs text-green-700 bg-green-100 px-3 py-1.5 rounded-full flex items-center gap-1.5">
                    <div className="h-2 w-2 bg-green-500 rounded-full animate-pulse"></div>
                    Live Updates Active
                  </div>
                ) : (
                  <div className="text-xs text-gray-600 bg-gray-100 px-3 py-1.5 rounded-full flex items-center gap-1.5">
                    <div className="h-2 w-2 bg-gray-400 rounded-full"></div>
                    Live Updates Paused
                  </div>
                )}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setAutoRefreshEnabled(!autoRefreshEnabled)}
                  className="text-xs"
                >
                  {autoRefreshEnabled ? 'Pause' : 'Resume'}
                </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            {isOrderLocked && (
              <Alert className="border-orange-300 bg-orange-50">
                <AlertTriangle className="h-5 w-5 text-orange-600" />
                <AlertDescription className="text-orange-900">
                  <p className="font-semibold text-base mb-2">
                    üîí Warehouse Receiving In Progress
                  </p>
                  <p className="text-orange-800 font-medium">
                    This order is currently being received at the warehouse.
                    Manufacturing operations are now <strong>view-only</strong> to prevent data conflicts.
                  </p>
                  <div className="mt-3 space-y-1 text-sm text-orange-800">
                    <p className="flex items-center gap-2">
                      <span className="text-green-600 font-bold">‚úì</span> You can view current batch progress
                    </p>
                    <p className="flex items-center gap-2">
                      <span className="text-green-600 font-bold">‚úì</span> You can download scan summary (Excel)
                    </p>
                    <p className="flex items-center gap-2">
                      <span className="text-red-600 font-bold">‚úó</span> Cannot scan new codes or link to master cases
                    </p>
                    <p className="flex items-center gap-2">
                      <span className="text-red-600 font-bold">‚úó</span> Cannot unlink or edit existing master cases
                    </p>
                  </div>
                  <p className="mt-3 text-xs text-orange-700 font-medium">
                    <strong>Warehouse Status:</strong> {currentBatchProgress.warehouse_received_cases || 0} of {currentBatchProgress.packed_master_codes} master cases received
                  </p>
                </AlertDescription>
              </Alert>
            )}

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between text-sm">
                  <span className="font-medium text-gray-700">Master Cases Packed</span>
                  <span className="text-gray-900 font-bold">
                    {currentBatchProgress.packed_master_codes} / {currentBatchProgress.total_master_codes}
                  </span>
                </div>
                <Progress value={masterPercent} className="h-3" />
                <p className="text-xs text-gray-600">
                  {masterPercent}% Complete
                </p>
              </div>

              <div className="space-y-2">
                <div className="flex items-center justify-between text-sm">
                  <span className="font-medium text-gray-700">Unique Codes Packed</span>
                  <span className="text-gray-900 font-bold">
                    {displayedPackedUniqueCount} / {plannedUniqueCount}
                  </span>
                </div>
                <Progress value={uniquePercent} className="h-3" />
                <div className="flex flex-wrap items-center justify-between text-xs text-gray-600 gap-2">
                  <span>{Math.round(uniquePercent)}% Complete</span>
                  {overflowPackedUniqueCount > 0 && (
                    <span className="text-amber-600 font-medium">
                      +{overflowPackedUniqueCount} buffer units packed
                    </span>
                  )}
                </div>
              </div>

              {/* Buffer Code Usage Display - Now in same row */}
              <div className="space-y-2">
                <div className="flex items-center justify-between text-sm">
                  <span className="font-medium text-gray-700">Buffer QR Codes Usage</span>
                  <span className="text-gray-900 font-bold">
                    {currentBatchProgress.used_buffer_codes} / {currentBatchProgress.total_buffer_codes > 0 ? currentBatchProgress.total_buffer_codes : 15}
                  </span>
                </div>
                <Progress 
                  value={currentBatchProgress.total_buffer_codes > 0 
                    ? (currentBatchProgress.used_buffer_codes / currentBatchProgress.total_buffer_codes) * 100 
                    : 0
                  } 
                  className="h-3" 
                />
                <p className="text-xs text-gray-600">
                  ({currentBatchProgress.total_buffer_codes > 0 
                    ? currentBatchProgress.total_buffer_codes - currentBatchProgress.used_buffer_codes 
                    : 15} available)
                </p>
              </div>
            </div>

            {/* Case-by-Case Breakdown */}
            {currentBatchProgress.packed_case_numbers && currentBatchProgress.packed_case_numbers.length > 0 && (
              <div className="bg-white border border-green-200 rounded-lg p-4">
                <h4 className="text-sm font-semibold text-gray-900 mb-3 flex items-center gap-2">
                  <Package className="h-4 w-4 text-green-600" />
                  Case Completion Status
                </h4>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  {/* Completed Cases */}
                  {currentBatchProgress.packed_case_numbers.length > 0 && (
                    <div className="bg-green-50 border border-green-200 rounded-lg p-3">
                      <div className="flex items-center gap-2 mb-2">
                        <CheckCircle className="h-4 w-4 text-green-600" />
                        <p className="text-xs font-semibold text-green-700 uppercase tracking-wide">
                          Completed ({currentBatchProgress.packed_case_numbers.length})
                        </p>
                      </div>
                      <p className="text-sm text-green-800 font-medium">
                        {formatCaseNumberRanges(currentBatchProgress.packed_case_numbers)}
                      </p>
                    </div>
                  )}

                  {/* Partial Cases */}
                  {currentBatchProgress.partial_case_numbers && currentBatchProgress.partial_case_numbers.length > 0 && (
                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                      <div className="flex items-center gap-2 mb-2">
                        <AlertTriangle className="h-4 w-4 text-yellow-600" />
                        <p className="text-xs font-semibold text-yellow-700 uppercase tracking-wide">
                          In Progress ({currentBatchProgress.partial_case_numbers.length})
                        </p>
                      </div>
                      <p className="text-sm text-yellow-800 font-medium">
                        {formatCaseNumberRanges(currentBatchProgress.partial_case_numbers)}
                      </p>
                    </div>
                  )}

                  {/* Empty Cases */}
                  {currentBatchProgress.empty_case_numbers && currentBatchProgress.empty_case_numbers.length > 0 && (
                    <div className="bg-gray-50 border border-gray-200 rounded-lg p-3">
                      <div className="flex items-center gap-2 mb-2">
                        <Package className="h-4 w-4 text-gray-400" />
                        <p className="text-xs font-semibold text-gray-600 uppercase tracking-wide">
                          Not Started ({currentBatchProgress.empty_case_numbers.length})
                        </p>
                      </div>
                      <p className="text-sm text-gray-700 font-medium">
                        {formatCaseNumberRanges(currentBatchProgress.empty_case_numbers)}
                      </p>
                    </div>
                  )}
                </div>

                <p className="text-xs text-gray-500 mt-3">
                  <strong>Tip:</strong> Use this to identify which cases need work. Empty case numbers indicate available slots for new packing.
                </p>
              </div>
            )}

            {/* Download Scan Summary Button */}
            <div className="flex flex-col gap-3">
              <div className="flex flex-col sm:flex-row gap-3 justify-end">
                <Button
                  onClick={handleDownloadScanSummary}
                  disabled={downloadingExcel}
                  variant="outline"
                  className="gap-2"
                >
                  <Download className="h-4 w-4" />
                  {downloadingExcel ? 'Generating Excel...' : 'Download Scan Summary (Excel)'}
                </Button>

                <Button
                  onClick={handleCompleteProduction}
                  disabled={completingProduction || isOrderLocked || masterPercent < 100 || currentBatchProgress?.batch_status === 'completed'}
                  variant="default"
                  className={`gap-2 font-semibold shadow-md disabled:cursor-not-allowed ${
                    currentBatchProgress?.batch_status === 'completed'
                      ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white'
                      : 'bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white disabled:opacity-50'
                  }`}
                  title={
                    currentBatchProgress?.batch_status === 'completed'
                      ? 'Production completed - batch is in transit to warehouse'
                      : masterPercent < 100
                        ? `Cannot complete: Only ${masterPercent}% packed. Must be 100% complete.`
                        : 'Mark production as complete and ready for warehouse shipment'
                  }
                >
                  <CheckCircle className="h-4 w-4" />
                  {completingProduction 
                    ? 'Completing...' 
                    : currentBatchProgress?.batch_status === 'completed'
                      ? 'In Transit to Serapod Warehouse'
                      : 'Production Complete - Ready to Ship'
                  }
                </Button>
              </div>
              
              {/* Balance Payment Info - Before Production Complete */}
              {currentBatchProgress?.batch_status !== 'completed' && masterPercent === 100 && (() => {
                const selectedOrderData = orders.find(o => o.id === selectedOrder)
                const balancePct = selectedOrderData?.payment_terms?.balance_pct || 0.5
                const balancePercentage = Math.round(balancePct * 100)
                return (
                  <p className="text-xs text-gray-600 mt-2 text-right">
                    üí° <strong>Note:</strong> Balance payment request ({balancePercentage}%) will be sent to admin when production is marked complete.
                  </p>
                )
              })()}

              {/* Balance Payment Notification - After Production Complete */}
              {currentBatchProgress?.batch_status === 'completed' && (() => {
                const selectedOrderData = orders.find(o => o.id === selectedOrder)
                const balancePct = selectedOrderData?.payment_terms?.balance_pct || 0.5
                const balancePercentage = Math.round(balancePct * 100)
                
                // Calculate total order amount from order items
                const orderItems = selectedOrderData?.order_items || []
                const orderTotal = orderItems.reduce((sum: number, item: any) => {
                  const lineTotal = parseFloat(item.line_total) || 0
                  return sum + lineTotal
                }, 0)
                
                // Debug logging
                console.log('Balance Payment Debug:', {
                  orderId: selectedOrder,
                  orderItems: orderItems.length,
                  orderTotal,
                  balancePct,
                  selectedOrderData
                })
                
                const balanceAmount = orderTotal * balancePct
                const formattedAmount = new Intl.NumberFormat('en-MY', {
                  style: 'currency',
                  currency: 'MYR',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2
                }).format(balanceAmount)
                
                return (
                  <p className="text-xs text-blue-600 mt-2 text-right font-medium">
                    ‚úì Balance payment ({balancePercentage}%) of {formattedAmount} notified to Serapod
                  </p>
                )
              })()}
            </div>
          </CardContent>
        </Card>
      )}

      {packingMode === 'scan_assign' && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {uniqueScanCard}
          {manualLinkCard}
        </div>
      )}

      {packingMode === 'bulk_generate' && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {uniqueScanCard}
          {bulkFinalizeCard}
        </div>
      )}

      {packingMode === 'plan_import' && (
        <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
          {planImportCard}
        </div>
      )}

      {packingMode === 'async_reverse' && (
        <ModeCReverseCaseView
          currentBatchProgress={currentBatchProgress}
          userProfile={userProfile}
          isOrderLocked={isOrderLocked}
          onJobComplete={() => {
            if (selectedOrder) {
              // Delay to ensure database transaction commits and data is available
              // Use longer delay and multiple refreshes to ensure UI updates
              setTimeout(() => {
                console.log('üîÑ [Mode C Complete] First refresh - loading orders and progress...')
                loadOrders().then(() => {
                  console.log('‚úÖ Orders loaded')
                  return loadProgress(selectedOrder)
                }).then(() => {
                  console.log('‚úÖ Progress loaded - all refreshes complete')
                })
              }, 2500) // Increased to 2.5 seconds to ensure Mode C worker completes all database updates
            }
          }}
        />
      )}
    </div>
  )
}
